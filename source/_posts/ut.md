---
title: 翻新旧项目之单元测试
date: 2024-04-27 10:40:15
---

## 前言

在以前, 前端似乎和单元测试没啥关系, 不过随着前后端分离, 前端应用变得广泛, 项目代码变得庞大, 单元测试这个

东西已经出现在前端开发的视野里

> 现在是e2e测试+AI开始出现在视野里了

@图1

用例数量

@图2

* 不过前端不同于后端, 只要没出现致命bug, 那就属于"也不是不能用"的范围
* 然后用户体验也很难被纳入绩效当中, 特别是互联网公司更注重流量或者数据,
所以前端一直是游离于安全与质量的边界
* 一般来说也只是推崇高质量代码, 并不会下多大成本来搞这一块
* 不过搞笑的是, 作为一个消费者, 如果软件操作体验不好, 只要有替代品我就不会再用了

背景啥的就不再多说了, 详见[翻新旧项目之eslint](/2024/04/20/eslint/)

## 一个小故事

不知道大家有没有遇到过这种场景, 开发时需要写一个函数, 然后恰好发现了项目里已经有一个

类似名字的函数, 但是谨慎而又想**偷懒**的你并没有选择直接用, 而是选择了阅读一下它的**源码**.

结果你发现这个函数有点复杂, **if分支**有点多, 函数**嵌套**也有点多...

你开始评估自己写的话需要多少时间, 开始猜测--自己**再拉一坨屎**会不会被committer发现并被打成**典型反面**案例

出于对前同事的信任(就是想**偷懒**), 你直接调用了这个函数

果不其然, 自测出问题了, 你花了点时间**修复**了这个函数**错误的逻辑**, 完美上线

然而, 在不久之后, 其它模块测试来找你了, 说其它开发排查到是你**引入**的问题...

好嘛, 原来之前的模块的**正确功能**是建立在函数的**错误表现**之上的, 结果你给改了

@图3

这是我以前遇到的情况的**概括**, 细节就不描述了

讲述这个小故事的原因很简单, 如果那个函数有一定的测试用例固化它原有的行为, 那么就会大大减少踩坑的概率

## 合适的单元测试

### 什么东西需要单元测试

前端的代码结构不同于后端, 它既包含了UI显示也包含了逻辑处理, 而逻辑处理有包含业务逻辑与基础逻辑

> 有时候还会包含数据, 数据的话一般不涉及测试

* 业务逻辑通常以一套流程的形式呈现, 比如 用户登录, 那么就需要调用判断用户是否存在, 如果不存在就需要跳到注册页面等等
* 而基础逻辑则是更小更容易复用的单元, 比如用户注册时对用户名的校验逻辑, 这个校验函数它也可以放到其它用到用户名的表单里

以我目前的经验来看, 需要根据项目对不同模块质量的要求, 对质量的方向, 开发的成本, 人员的能力来进行选择

1. 对页面的**性能**要求高(加载快, 页面响应快), 这个**不适合**用**单元测试**, 而是应该用**端到端测试**里面
2. 质量要求比较高(绝**不**能有**bug**), 开发**资源支持**全员写测试用例, 这种情况下需要**全面**的单元**测试**,
包括业务组件, 公共组件, 公共函数

3. 质量要求一般, 开发资源较少, 需求变更快, 这种不适合用单元测试覆盖业务逻辑与公共组件, 完成**需求为主**,
  **基础**的公共逻辑可以使用**单元测试**覆盖, 以避免需求变更时影响到其它模块,

### 实操

经过两天的观察, 我发现项目与代码质量相关的问题有:

1. 部分组件封装逻辑有问题, 并且里面还有错误代码
2. 公共js组件较少, 业务项目的类似函数很多
3. 封装出的api很难用, 虽有注释, 但命名与用途不符
4. 多数函数的返回值不一致, 即在某些情况下会返回期望类型, 某些时候会返回null, NaN
5. 部分公共api耦合全局变量
6. 负责人已经开始使用公共组件库的组件

比如

```js
  // 这是用于封装Storage的对象中的一个方法
    /**
   * 获取sessionStorage/localStorage的值
   * @param {String} key 存储key
   * @param {String} [type] 'session' || 'local'
   * @returns {String|Object|Array}
   */
  const STORAGE_KEY_MAP = {
    local: 'localStorage',
    session: 'sessionStorage'
  }

  getItem(key, type) {
    type = this.getType(type)
    try {
      const value = window[STORAGE_KEY_MAP[type]].getItem(key)
      return JSON.parse(value)
    } catch (error) {
      console.error(error)
      return ''
    }
  },
```

这玩意我写单测的时候有点迷糊, 没仔细看代码直接写的用例, 后来发现好几个用例不通过

```js
  test('getItem 用例1', () => {
    expect(API.getItem('name', 'session')).toBe(null)

    sessionStorage.setItem('name', '123')

    expect(API.getItem('name', 'session')).toBe('123') // 这行不通过
    expect(sessionStorage.getItem('name')).toBe('123')
  })
```

然后一看代码, 它直接用`JSON.parse(value)`处理返回值,

好嘛, '123'变成了123,
然后'abc'的话就返回空字符串

还有一个叫做checkSomething的函数, 它里面既包含了判断逻辑, 又包含了纠正something的逻辑

直接无敌了, 返回值还是undefined或者bool

这种公共api怎么让人用

> 从原则来说, 它违反了单一职责原则
> 从规范来说, 它属于名不副实的典型案例

以上种种意味着

1. 以后需要将很多函数收编到组件库, 如果不做其他事, 那么大概率会出问题
2. 需要**强制**要求组员使用公共函数而不是自己**造轮子**
3. 需要尽快排查现有组件库的公共函数, 尽早发现问题
4. 对开发人员进行指导, 尽量别污染公共组件库

> 想要强制推行公共函数, 组员的开发素质是一方面, 更重要的是要让公共函数易用和稳定
> 易用包含两方面, 一是需要文档或者清晰的用例描述, 二是函数名好记
> 稳定则是也可以用单元测试来保证

### 选择

虽然单元测试的**成本**比起端到端测试要低, 但是对于开发人员来说还是有点**高**的, 很有可能会持平开发成本.

综上, 我选择的是只给组件库的公共函数加上全面的单元测试, 因为这些公共函数被复用的概率远

高于其它公共组件, 补全测试用例的成本也不高, 属于低成本高收益.

### UI组件的测试

至于说UI组件, 以后再说...这玩意成本高, 收益低, 变更频率可能不低
其实UI组件的单元测试是有个方向的, 可以考虑使用Playwright或者Cypress(sorry cypress),
它们可以根据操作自动生成测试代码与捕捉网络数据进行重现

## 怎么加单元测试

这个在网上也已经有了成熟的解决方案, 例如jest, puppeteer, vitest, Sinon, MochaJS等

由于只是想给js加上单元测试, 所以选择了最基础的jest

### 安装jest

eslint篇已经说过怎么解决nodejs版本低的问题, 所以就不在此描述了

按照官网文档安装jest@23.6.0, @types/jest@23.3.14(以便编辑器进行代码提示)

> 之所以不装最新版本, 那是因为nodejs版本太低, 只能用这个版本的jest
> node@14.16.1 + babel@6

@图4

然后进行配置

```JavaScript
// jest.config.js
// 以下为修改项, 其他的保持默认就好
{
  clearMocks: true,
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^@ui/(.*)$': '<rootDir>/src/ui/$1',
    '^@js/(.*)$': '<rootDir>/src/js/$1',
  },
  testMatch: ['**/tests/**/?(*.)+(spec|test).[tj]s?(x)'],
  testPathIgnorePatterns: ['node_modules'],
  transform: {
    '^.+\\.js$': 'babel-jest',
  },
}

// .babelrc
// 使用babel进行解析js
{
  "env": {
    "test": {
      "presets": [["env"]]
    }
  }
}

// jsconfig.json
// 代码提示
{
  "typeAcquisition": {
    "include": [
      "jest"
    ]
  }
}
```

配置husky, 在push时进行单元测试

```shell
# .husky/pre-push

#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

cd project && npm test
```

```json
// package.json

  "scripts": {
    "test": "jest"
  },
```

### 问题二用例怎么写

单个用例分为描述和测试代码

```js
describe('描述1', () => {
  test('描述2', () => {
    // 测试代码
  })
})
```

* 一个良好的描述可以部分代替文档或者起到补充的作用
* 由于测试代码一般来说会比开发代码要多, 所以它更需要良好的组织逻辑

组织逻辑指的是:

1. 划分模块,
2. 提取公共函数,
3. 对常用的第三方模块进行集中mock和restore(如console, moment)
4. 大规模测试数据需要单独放置以便重复使用
5. 先写边界, 如处理null, undefined, 再写错误情况

多个用例必然会涉及到不同模块与功能

* 所以可以用**目录**区分**模块**, **文件**区分**功能**, **描述**(describe)区分**场景**

@图5

与此同时, 这些用例也会涉及到相同的api, 数据或者输出处理

比如都需要模拟console的某些方法, 然后检查这些方法是否被调用

这个时候就应该将相同的部分写在

beforeEach, afterEach, beforeAll, afterAll或者setupfile里面

```js
  beforeAll(() => {
    jest.spyOn(console, 'error').mockImplementation(() => {})
  })

  afterAll(() => {
    console.error.mockRestore()
  })

  afterEach(() => {
    console.error.mockClear()
  })
```

### 问题二怎么确保用例覆盖完全

这个只能按照经验来说了, 就如前面所说的, 先写错误, 再写边界, 最后写
正常情况

> 有一个比较简单但是不靠谱的方法, 那就是看coverage里面的覆盖率

### 问题三单元测试有什么优点

一般来说大家提的都是些提高代码质量, 发现代码bug之类的套话, 我来说点其它方面的见解

1. 快速且较为全面的理解某个模块或者函数的功能(避免命名牛头不对马嘴的情况)
2. 固化原有行为, 便于之后进行修改或者重构
3. 通过编写大量测试用例, 理解什么是易于测试的模块, 提高编码能力

当然对我这个项目来说, 主要是第二点
